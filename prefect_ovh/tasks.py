import datetime
import json
import time

from ov_hcloud_ai_solution_client import AuthenticatedClient
from ov_hcloud_ai_solution_client.api.job import (
    job_delete,
    job_get,
    job_kill,
    job_log,
    job_new,
    job_start,
)
from ov_hcloud_ai_solution_client.api.me import me
from ov_hcloud_ai_solution_client.models import Job, JobSpec, Me
from ov_hcloud_ai_solution_client.types import Response
from prefect import task
from prefect.blocks.notifications import AppriseNotificationBlock
from prefect.exceptions import PrefectException


@task(name="Create a python client with unique usage")
def create_client(token: str) -> AuthenticatedClient:
    """Create an authenticated client for the SDK python
    We test if your token is correct

    Args:
        token (str): Your bearer token from OVHcloud

    Raises:
        PrefectException: If your token is not valid

    Returns:
        AuthenticatedClient: Your client authenticated
    """
    client = AuthenticatedClient(
        base_url="https://gra.training.ai.cloud.ovh.net", token=token
    )
    with client as client:
        response: Me = me.sync_detailed(client=client)
    if response.status_code == 200:
        # Because client can make one call to the api we recreate a client
        client = AuthenticatedClient(
            base_url="https://gra.training.ai.cloud.ovh.net", token=token
        )
        return client
    else:
        raise PrefectException("Your token is not valid " + response.content.decode())


@task(name="submit an AI Training job to OVHcloud")
def submit_job(
    client: AuthenticatedClient,
    image: str,
    http_port: int = 8080,
    command: list = [],
    listEnvVars: list = [],
    dicLabels: dict = {},
    name: str = None,
    cpu: int = 0,
    gpu: int = 1,
    sshPublicKeys: list = [],
    volumes: list = [],
    timeout: int = 0,
) -> dict:
    """Submit a job to the OVHcloud AI Training tool

    Args:
        client (AuthenticatedClient): the python client
        image (str): The docker image
        http_port (int, optional): default http port. Defaults to 8080.
        command (list, optional): command to run . Defaults to [].
        listEnvVars (list, optional): your environments variables. Defaults to [].
        dicLabels (dict, optional): some labels for the job. Defaults to {}.
        name (str, optional): the name of the job. Defaults to None.
        cpu (int, optional): the number of cpu. Defaults to 0.
        gpu (int, optional): the number of gpu. Defaults to 1.
        sshPublicKeys (list, optional): some ssh keys. Defaults to [].
        volumes (list, optional): the git repo or object storage repo or S3.
            Defaults to [].
        timeout (int, optional): timeout for the job. Defaults to 0 (no timeout).

    Raises:
        PrefectException: Exception to provide if the job failed to submitted

    Returns:
        Dict: The detail of the job submitted in a json file
    """
    # First of all we create the request to send to the core API
    request = {
        "command": command,
        "defaultHttpPort": http_port,
        "deletionRequested": False,
        "envVars": listEnvVars,
        "labels": dicLabels,
        "image": image,
        "name": name,
        "resources": {"cpu": cpu, "gpu": gpu},
        "sshPublicKeys": sshPublicKeys,
        "volumes": volumes,
        "timeout": timeout,
    }
    # If there is no name, it will be auto generated by OVHcloud
    if name is None:
        name = request.pop("name")
    # If CPU is indicated, we set the number of gpu to 0
    if cpu != 0:
        request.update({"resources": {"cpu": cpu, "gpu": 0}})
    # Submit the job to OVHcloud
    with client as client:
        response: Response[Job] = job_new.sync_detailed(
            client=client, json_body=JobSpec.from_dict(request)
        )
    # We check if the job is submitted to the AI Training tool
    if response.status_code != 200:
        raise PrefectException(
            "Your Job can't be run !, here is the reason :", response.content.decode()
        )
    else:
        return json.loads(response.content.decode())


@task(name="Check if an AI Training job is not failed")
def check_if_job_has_failed(
    state: str,
    client: AuthenticatedClient,
    id_job: str,
    telegram_webhook: AppriseNotificationBlock,
) -> bool:
    """Check if the job has not a failed status

    Args:
        state (str): the job's state
        client (AuthenticatedClient): the client from sdk python
        id(str): the id of your job
        telegram_webhook (AppriseNotificationBlock): the webhook to send a notif on tlg

    Raises:
        PrefectException: if the job is failed, interrupted or stopped

    Returns:
        bool: true if everything went well
    """
    # We check if the run is not broken
    if state == "INTERRUPTED" or state == "FAILED" or state == "ERROR":
        # Get the logs of the application
        with client as client:
            logs = job_log.sync_detailed(id=id_job, client=client)
        if logs.status_code != 200:
            raise PrefectException(f"We can't access the logs of your job {id_job}")
        else:
            message = None
            if telegram_webhook is not None:
                message = (
                    str(datetime.datetime.now(datetime.timezone.utc))
                    + f" [prefect] Your job {id_job} didn't entered done state "
                    + "Here are the logs :"
                    + f"{logs.content.decode()}"
                )
            if state == "INTERRUPTED":
                if message:
                    telegram_webhook.notify(message)
                raise PrefectException(
                    f"Your job {id_job} is interrupted, here are the logs \n"
                    + f"{logs.content.decode()}"
                )
            if state == "FAILED":
                if message:
                    telegram_webhook.notify(message)
                raise PrefectException(
                    f"Your job {id_job} has failed, here are the logs \n"
                    + f"{logs.content.decode()}"
                )
            if state == "ERROR":
                if message:
                    telegram_webhook.notify(message)
                raise PrefectException(
                    f"Your job {id_job} has an error in the parameter,"
                    + " here are the logs \n"
                    + f"{logs.content.decode()}"
                )
    else:
        return True


@task(name="Check the job's timeout")
def check_time_out_job(
    timeout: float, start: float, id: str, client: AuthenticatedClient
) -> bool:
    """Check if maximum time has not been reached

    Args:
        timeout (float): the maximum time to run the job
        start (float): a time in a float format when the job has been submit
        id (str): the id of the job
        client (AuthenticatedClient): client for the sdk python

    Raises:
        PrefectException: raise an exception if time is reached

    Returns:
        bool: true if everything went well
    """
    if timeout and start + timeout < time.monotonic():
        # We stop the job
        with client as client:
            response: Response[Job] = job_kill.sync_detailed(id=id, client=client)
        # We check if he has been stopped and send a prefect exeception
        if response.status_code != 200:
            raise PrefectException(
                f"Timeout exceeded for the job {id} ! and we can't stop it !"
            )
        else:
            raise PrefectException(
                f"Timeout exceeded for the job {id}, he has been stopped"
            )
    else:
        return True


@task(name="Get the status of the job")
def get_state_job(id: str, client: AuthenticatedClient) -> str:
    """Get the status of the AI Training job

    Args:
        id (str): the id of your job
        client (AuthenticatedClient): the client from SDK python

    Raises:
        PrefectException: If we can't get the status of the job

    Returns:
        str: the job's status (DONE, FAILED ...)
    """
    with client as client:
        response: Response[Job] = job_get.sync_detailed(id=id, client=client)
    # We check if you have the new informations of the job
    if response.status_code != 200:
        raise PrefectException(
            "We can't get the infos of your job, here is the reason : "
            + f"{response.content.decode()}"
        )
    # We get the content of the response
    response_content = response.content.decode()
    # We transform the response as a dict
    response_dict = json.loads(response_content)
    # We get the status of the job
    state = response_dict["status"]["state"]
    return state


@task(name="send a message with the status of the bot")
def send_message_with_state(
    state: str, id: str, telegram_webhook: AppriseNotificationBlock
):
    """Send a message to the user

    Args:
        state (str): the state of the job_
        id (str): the AI Training job ID
        telegram (bool): a bool variable to determine
            if we sent a telegram message
        telegram_webhook(AppriseNotificationBlock): Telegram webhook
            to send notification
    """
    # We create the message
    message = (
        str(datetime.datetime.now(datetime.timezone.utc))
        + f" [prefect] Wait, your job {id} is in state "
        + state
    )
    if telegram_webhook is not None:
        # We notify on telegram
        telegram_webhook.notify(message)
    print(message)


@task(name="Get all infos of the AI Training job")
def get_infos_of_job(id_job: str, client: AuthenticatedClient) -> dict:
    """Get all infos of an OVHcloud's job
    Args:
        id_job (str): the id of the job
        client (AuthenticatedClient): The Authenticated client

    Raises:
        PrefectException: If the id of the job is wrong

    Returns:
        dict: The response in a json format
    """
    with client as client:
        response: Response[Job] = job_get.sync_detailed(id=id_job, client=client)
    # We check if the job is existing
    if response.status_code == 200:
        return json.loads(response.content.decode())
    else:
        raise PrefectException(
            "We can't get the infos of this job : " + response.content.decode()
        )


@task(name="get the logs of the AI Training job")
def get_logs_of_job(id_job: str, client: AuthenticatedClient) -> str:
    """Get the logs of an OVHcloud's job

    Args:
        id_job (str): the id of the job
        client (AuthenticatedClient): The client for the SDK Python
    Raises:
        PrefectException: If we can't provide the logs of the job

    Returns:
        str: The response as a log from OVHcloud
    """
    with client as client:
        response: Response[Job] = job_log.sync_detailed(id=id_job, client=client)
    if response.status_code == 200:
        return response.content.decode()
    else:
        raise PrefectException(
            f"We can't get the logs of this job : {response.content.decode()}"
        )


@task(name="Start an existing job")
def start_an_existing_job(id_job: str, client: AuthenticatedClient) -> dict:
    """Start an existing job from AI Training

    Args:
        id_job (str): The id of the job
        client (AuthenticatedClient): the authenticated client for SDK python

    Raises:
        PrefectException: The exception if we can't start this job

    Returns:
        dict: the dictionnary with the information of the job
    """
    with client as client:
        response: Response[Job] = job_start.sync_detailed(id=id_job, client=client)
    if response.status_code == 200:
        return json.loads(response.content.decode())
    else:
        raise PrefectException(f"We can't start this job {response.content.decode()}")


@task(name="stop an existing AI Training job")
def stop_job(id_job: str, client: AuthenticatedClient) -> dict:
    """Stop an existing job from AI Training

    Args:
        id_job (str): The id of the job
        client (AuthenticatedClient): the authenticated client for SDK python

    Raises:
        PrefectException: The exception if we can't stop this job

    Returns:
        dict: the dictionnary with the information of the job
    """
    with client as client:
        response: Response[Job] = job_kill.sync_detailed(id=id_job, client=client)
    if response.status_code == 200:
        return json.loads(response.content.decode())
    else:
        raise PrefectException(f"We can't stop this job {response.content.decode()}")


@task(name="Delete an existing job")
def delete_job(id_job: str, client: AuthenticatedClient) -> dict:
    """Delete an existing job from AI Training

    Args:
        id_job (str): The id of the job
        client (AuthenticatedClient): the authenticated client for SDK python

    Raises:
        PrefectException: The exception if we can't delete this job

    Returns:
        dict: the dictionnary with the information of the job
    """
    with client as client:
        response: Response[Job] = job_delete.sync_detailed(id=id_job, client=client)
    if response.status_code == 204:
        return id_job
    else:
        raise PrefectException("We can't delete this job ")


@task(name="Create a webhook to notify for telegram")
def create_webhook_telegram(
    chat_id: str, api_telegram: str
) -> AppriseNotificationBlock:
    """Create a webhook to send notification to telegram

    Args:
        chat_id (str): your secret chat id from telegram
        api_telegram (str): your secret id for the api telegram

    Returns:
        AppriseNotificationBlock: the webhook to send notification
    """
    # We create the hook for telegram
    telegram_webhook_block = AppriseNotificationBlock(
        url=f"tgram://{api_telegram}/{chat_id}/"
    )
    return telegram_webhook_block
